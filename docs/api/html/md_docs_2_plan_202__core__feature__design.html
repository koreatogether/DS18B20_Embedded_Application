<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DS18B20 Embedded Application: 센서별 사용자 데이터(ID) 저장/조회/중복 체크 ✅ 완료</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DS18B20 Embedded Application
   </div>
   <div id="projectbrief">Arduino UNO R4 WiFi 기반 DS18B20 온도센서/메모리 분석 시스템 문서화</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 다음에 의해 생성됨 :  Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','검색',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md_docs_2_plan_202__core__feature__design.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">로딩중...</div>
<div class="SRStatus" id="Searching">검색중...</div>
<div class="SRStatus" id="NoMatches">일치하는것 없음</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">센서별 사용자 데이터(ID) 저장/조회/중복 체크 ✅ 완료 </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md18"></a></p>
<ul>
<li><b>설계 의도:</b><ul>
<li>각 DS18B20 센서에 대해 사용자가 임의의 식별자(ID)를 부여, 저장, 조회, 중복 체크할 수 있도록 한다.</li>
<li>센서 주소와 사용자 ID의 매핑을 통해 센서 관리의 편의성과 확장성을 높인다.</li>
</ul>
</li>
<li><b>구조 및 책임:</b><ul>
<li>setSensorId(index, id): 지정한 센서에 사용자 ID를 저장</li>
<li>getSensorId(index): 지정한 센서의 사용자 ID를 반환</li>
<li>isIdDuplicated(id): ID 중복 여부를 검사</li>
<li>내부적으로 sensorIds_ 벡터(또는 map)로 주소-사용자ID 매핑 관리</li>
</ul>
</li>
<li><b>주요 흐름:</b><ol type="1">
<li>setSensorId() 호출 시 해당 인덱스의 ID를 갱신, 중복 검사</li>
<li>getSensorId()로 센서별 ID 조회</li>
<li>isIdDuplicated()로 전체 ID 중복 여부 확인</li>
</ol>
</li>
<li><b>예외 처리:</b><ul>
<li>인덱스 범위 오류, 빈 문자열, 중복 ID 등은 false 반환 또는 예외 처리</li>
<li>ID가 없는 경우 빈 문자열 반환</li>
</ul>
</li>
<li><b>구현 완료:</b><ul>
<li>✅ <a class="el" href="class_temperature_sensor_manager.html">TemperatureSensorManager</a> 클래스에 ID 관리 메서드 구현</li>
<li>✅ Unity 테스트 프레임워크로 정상/예외 케이스 검증</li>
<li>✅ 테스트용 메서드(_test_setSensorIds) 추가로 유닛 테스트 지원</li>
<li>✅ 설계 문서 및 계획서 동기화 완료</li>
</ul>
</li>
</ul>
<p># </p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md19"></a>
에러 처리(-127.0 등) 및 예외 상황 관리 ✅ 완료</h2>
<ul>
<li><b>설계 의도:</b><ul>
<li>DS18B20 센서의 온도 측정 시 발생할 수 있는 에러값(-127.0 등) 및 예외 상황을 일관되게 관리한다.</li>
<li>센서 연결 상태, 온도값 유효성, 에러 코드/메시지 제공 등 robust한 도메인 계층을 구현한다.</li>
</ul>
</li>
<li><b>구조 및 책임:</b><ul>
<li>SensorErrorCode enum: 에러 코드 정의 (NO_ERROR, SENSOR_DISCONNECTED, INVALID_TEMPERATURE 등)</li>
<li>isTemperatureValid(float temp): 온도값 유효성 검사</li>
<li>getLastErrorCode(), getErrorMessage(): 최근 에러 코드/메시지 반환</li>
<li>isSensorConnected(index): 센서 연결 상태 확인</li>
<li>clearLastError(), setLastError(): 에러 상태 관리</li>
<li>isValidIndex(index): 인덱스 범위 체크</li>
</ul>
</li>
<li><b>주요 흐름:</b><ol type="1">
<li>readTemperature() 등에서 온도값이 에러값(-127.0 등)이면 에러 코드/메시지 설정</li>
<li>isTemperatureValid()로 온도값의 정상 여부 판단</li>
<li>getLastErrorCode()/getErrorMessage()로 에러 상태 조회</li>
<li>isSensorConnected()로 센서 연결 상태 확인</li>
</ol>
</li>
<li><b>예외 처리:</b><ul>
<li>인덱스 범위 오류, 센서 미연결, 에러값(-127.0 등)은 적절한 에러 코드/메시지로 반환</li>
<li>에러 발생 시 내부 상태에 기록, 필요시 clearLastError()로 초기화</li>
</ul>
</li>
<li><b>구현 완료:</b><ul>
<li>✅ TemperatureSensorManager에 에러 처리/예외 관리 메서드 및 enum 구현</li>
<li>✅ 테스트 케이스(test_temperature_sensor.cpp) 및 문서 동기화 완료</li>
<li>✅ 설계 문서 및 계획서 동기화 완료</li>
</ul>
</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md20"></a>
DS18B20 Domain Layer Core Feature Progress (계획-설계-구현-테스트-문서화-자동화 동기화)</h1>
<hr  />
 <h2 class="doxsection"><a class="anchor" id="autotoc_md22"></a>
장시간 동작 안정성(롱런) 테스트 전략 (Application/Test/QA)</h2>
<ul>
<li><b>목적:</b> 임베디드 시스템이 7일 이상 연속 동작 시 메모리 누수, 에러, 품질 저하 없이 안정적으로 동작하는지 검증</li>
<li><b>Mock 기반:</b> MockLongRunStabilityManager 헤더온리 mock 객체로 실제 7일 시나리오를 5분 내 반복 루프(300회)로 가속화하여 자동 검증</li>
<li><b>테스트 자동화:</b> 모든 시나리오(정상, 에러, 누수, 요약 등)는 header-only, RTTI-free, mock 기반으로 통합 테스트 파일에서 자동화</li>
<li><b>가상 시간 스케일:</b> 실제 1초를 수천 초로 가정하여 반복 횟수만큼 빠르게 품질 시나리오를 시뮬레이션</li>
<li><b>장점:</b> 실제 장시간 동작 환경을 수분 내에 반복 검증, CI/CD 및 로컬 PC에서 품질 회귀 테스트에 즉시 활용 가능</li>
</ul>
<p>이 문서의 각 단계는 아래와 같은 일관된 워크플로우를 따릅니다:</p>
<ul>
<li><b>설계/구현/테스트/문서화/자동화/체크리스트 동기화</b><ol type="1">
<li>설계 및 책임 정의 → 코드/테스트/문서 파일 생성 및 수정</li>
<li>PlatformIO 빌드/테스트로 기능 검증</li>
<li>관련 설계 문서 및 체크리스트(frimePlan.md) 동기화</li>
<li>auto_commit.sh 등 자동화 스크립트로 스테이징(커밋/푸시는 수동) </li>
</ol>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md23"></a>
5. 각 단계별 완료 시, 문서 상단에 ✅ 및 요약 추가, 계획과 문서의 일치 보장</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md24"></a>
ITemperatureSensor 인터페이스 정의 ✅ 완료</h3>
<h3 class="doxsection"><a class="anchor" id="autotoc_md25"></a>
TemperatureSensorManager 클래스 설계 ✅ 완료</h3>
<blockquote class="doxtable">
<p>[v] <a class="el" href="class_temperature_sensor_manager.html">TemperatureSensorManager</a> 클래스 설계, 책임 정의, 주요 메서드 시그니처, 설계 고려사항 등 완료. </p>
</blockquote>
<h3 class="doxsection"><a class="anchor" id="autotoc_md26"></a>
센서 자동 탐지 및 주소 관리 로직 ✅ 완료</h3>
<blockquote class="doxtable">
<p>[v] 센서 자동 탐지 및 주소 관리 로직 설계, 구조, 책임, 주요 흐름, 예외 처리 방안까지 완료. </p>
</blockquote>
<h3 class="doxsection"><a class="anchor" id="autotoc_md27"></a>
센서별 온도 측정/수집/갱신 메서드 ✅ 완료</h3>
<blockquote class="doxtable">
<p>[v] 센서별 온도 측정/수집/갱신 메서드 설계, 구조, 책임, 주요 흐름, 예외 처리 방안까지 완료. </p>
</blockquote>
<hr  />
 <h3 class="doxsection"><a class="anchor" id="autotoc_md29"></a>
센서별 온도 측정/수집/갱신 메서드</h3>
<ul>
<li><b>설계 의도:</b><ul>
<li>각 DS18B20 센서의 온도를 개별적으로 측정하고, 필요 시 전체 센서의 온도값을 일괄 수집/갱신할 수 있도록 한다.</li>
<li>온도값은 실시간 측정 또는 주기적 갱신 방식 모두 지원 가능하도록 설계한다.</li>
</ul>
</li>
<li><b>구조 및 책임:</b><ul>
<li>readTemperature(index): 지정한 센서의 현재 온도를 반환</li>
<li>updateAllTemperatures(): 모든 센서의 온도를 한 번에 측정하여 내부 캐시에 저장(옵션)</li>
<li><a class="el" href="class_i_temperature_sensor.html">ITemperatureSensor</a> 인터페이스의 read() 또는 readAll()을 활용하여 하드웨어 독립적 구현</li>
</ul>
</li>
<li><b>주요 흐름:</b><ol type="1">
<li>readTemperature(index) 호출 시 해당 센서 주소로 ITemperatureSensor::read(address) 실행</li>
<li>updateAllTemperatures()는 전체 주소 목록을 순회하며 온도값을 일괄 측정/저장</li>
<li>getCachedTemperature(index)는 내부 벡터에서 최근 측정값 반환(옵션)</li>
</ol>
</li>
<li><b>예외 처리:</b><ul>
<li>인덱스 범위 오류 등은 false/NaN/특정 값 반환</li>
</ul>
</li>
</ul>
<hr  />
 <h3 class="doxsection"><a class="anchor" id="autotoc_md31"></a>
센서 자동 탐지 및 주소 관리 로직</h3>
<ul>
<li><b>설계 의도:</b><ul>
<li>시스템이 부팅되거나 사용자가 요청할 때, 1-Wire 버스에 연결된 모든 DS18B20 센서를 자동으로 탐지하여 고유 8바이트 주소를 수집/저장합니다.</li>
<li>센서 주소 목록은 TemperatureSensorManager가 관리하며, 센서별 온도 측정/ID 매핑의 기준이 됩니다.</li>
</ul>
</li>
<li><b>구조 및 책임:</b><ul>
<li>discoverSensors() 메서드는 <a class="el" href="class_i_temperature_sensor.html">ITemperatureSensor</a> 인터페이스(실제 하드웨어 드라이버)를 통해 센서 주소를 반복적으로 검색합니다.</li>
<li>중복 없이 주소 벡터(sensorAddresses_)에 저장하고, 센서 개수에 맞춰 sensorIds_ 벡터도 동기화합니다.</li>
<li>센서가 추가/제거될 경우에도 일관된 주소 관리가 가능하도록 설계합니다.</li>
</ul>
</li>
<li><b>주요 흐름:</b><ol type="1">
<li>discoverSensors() 호출 시 기존 주소/ID 목록 초기화</li>
<li>ITemperatureSensor::search() 등 하드웨어 API로 1-Wire 버스의 모든 센서 주소 탐색</li>
<li>각 주소를 sensorAddresses_에 저장, sensorIds_는 빈 문자열로 초기화</li>
</ol>
</li>
<li><b>예외 처리:</b><ul>
<li>센서가 하나도 없을 경우, getSensorCount()는 0을 반환</li>
<li>주소 중복, 버스 에러 등은 추후 예외 정책에 따라 처리 예정</li>
</ul>
</li>
</ul>
<hr  />
 <h3 class="doxsection"><a class="anchor" id="autotoc_md33"></a>
TemperatureSensorManager 클래스 설계</h3>
<pre class="fragment">- 여러 DS18B20 센서를 자동 탐지하고, 각 센서의 주소를 관리하며, 온도 측정/수집/갱신 기능을 제공하는 도메인 계층의 핵심 매니저 클래스입니다.
- 각 센서별로 사용자 정의 ID를 저장/조회/중복 체크하며, 센서 에러(-127.0 등) 및 예외 상황을 일관되게 처리합니다.
</pre><ul>
<li><b>주요 책임:</b><ul>
<li>센서 자동 탐지 및 주소 목록 관리</li>
<li>센서별 온도 측정 및 데이터 갱신</li>
<li>센서별 사용자 데이터(ID) 저장/조회/중복 체크</li>
<li>에러 및 예외 상황 관리</li>
</ul>
</li>
<li><b>주요 메서드 시그니처(예시):</b> <div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_class" href="class_temperature_sensor_manager.html">TemperatureSensorManager</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">        <a class="code hl_class" href="class_temperature_sensor_manager.html">TemperatureSensorManager</a>();</div>
<div class="line">        <a class="code hl_class" href="class_temperature_sensor_manager.html">~TemperatureSensorManager</a>();</div>
<div class="line">        <span class="keywordtype">void</span> discoverSensors(); <span class="comment">// 센서 자동 탐지</span></div>
<div class="line">        <span class="keywordtype">size_t</span> getSensorCount() <span class="keyword">const</span>;</div>
<div class="line">        <span class="keywordtype">bool</span> getSensorAddress(<span class="keywordtype">size_t</span> index, uint8_t* address) <span class="keyword">const</span>;</div>
<div class="line">        <span class="keywordtype">float</span> readTemperature(<span class="keywordtype">size_t</span> index);</div>
<div class="line">        std::string getSensorId(<span class="keywordtype">size_t</span> index) <span class="keyword">const</span>;</div>
<div class="line">        <span class="keywordtype">bool</span> isIdDuplicated(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>) <span class="keyword">const</span>;</div>
<div class="line">        <span class="comment">// ... 기타 예외/에러 처리 메서드</span></div>
<div class="ttc" id="aclass_temperature_sensor_manager_html"><div class="ttname"><a href="class_temperature_sensor_manager.html">TemperatureSensorManager</a></div><div class="ttdef"><b>Definition</b> TemperatureSensorManager.h:22</div></div>
</div><!-- fragment --></li>
<li><b>설계 시 고려사항:</b><ul>
<li>센서 주소와 사용자 ID의 매핑 구조(예: std::map 등) 활용</li>
<li>예외 상황(센서 미연결, 에러값 등) 처리 정책 명확화</li>
</ul>
</li>
</ul>
<hr  />
 <h1 class="doxsection"><a class="anchor" id="autotoc_md35"></a>
02. 핵심 기능 설계 및 구현</h1>
<p>이 문서는 DS18B20 Embedded Application의 핵심 기능(센서 관리, 메모리 분석, 통신, 의존성 주입 등) 설계 및 구현 과정을 기록합니다.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md36"></a>
목차</h2>
<ol type="1">
<li>DS18B20 센서 관리 (Domain Layer)</li>
<li>메모리 분석 시스템 (Application Layer)</li>
<li>통신 및 명령어 처리 (Infrastructure Layer)</li>
<li>의존성 주입 및 통합 (Main Layer)</li>
<li>설계 의사결정/이슈/토의</li>
</ol>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md38"></a>
1. DS18B20 센서 관리 (Domain Layer)</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md39"></a>
ITemperatureSensor 인터페이스 정의</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md40"></a>
개발 및 자동화 과정 기록</h4>
<ul>
<li><b>파일 생성 위치:</b><ul>
<li><span class="tt"><a class="el" href="_i_temperature_sensor_8h_source.html">src/domain/ITemperatureSensor.h</a></span> 파일을 생성하여 DS18B20 센서 추상화를 위한 인터페이스를 정의함.</li>
</ul>
</li>
<li><b>빌드 및 테스트:</b><ul>
<li>PlatformIO 환경에서 <span class="tt">C:\Users\h\.platformio\penv\Scripts\platformio.exe run -e uno_r4_wifi</span> 명령으로 빌드.</li>
<li><span class="tt">C:\Users\h\.platformio\penv\Scripts\platformio.exe test -e native</span> 명령으로 유닛테스트를 수행하여 인터페이스 정의의 적합성 및 프로젝트 정상 동작을 검증함.</li>
</ul>
</li>
<li><b>자동화 스크립트 도입 배경:</b><ul>
<li>반복적인 빌드, 테스트, git add/commit/push 과정을 자동화하고, 각 단계별 에러 발생 시 즉시 중단 및 명확한 메시지 출력을 위해 <span class="tt">tools/auto_commit.sh</span> 스크립트를 도입함.</li>
<li>해당 스크립트는 빌드, 테스트, git add/commit/push를 일괄 처리하며, 변경사항이 없을 경우 커밋을 생략하고, 에러 발생 시 원인별로 종료 코드를 반환함.</li>
<li>Windows 환경에서는 Git Bash 또는 WSL에서 <span class="tt">bash tools/auto_commit.sh</span>로 실행 가능하며, 프로젝트의 일관된 품질 관리와 개발 효율성 향상에 기여함.</li>
</ul>
</li>
</ul>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md42"></a>
2. 메모리 분석 시스템 (Application Layer)</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md43"></a>
IMemoryAnalyzer 인터페이스 정의 ✅ 완료</h3>
<ul>
<li><b>설계 의도:</b><ul>
<li>메모리 분석 시스템의 핵심 기능을 추상화하여 하드웨어 독립적인 메모리 모니터링 및 분석을 제공합니다.</li>
<li>런타임 분석, 구조 분석, 주기적 모니터링, 추적 기능 등을 통합적으로 관리합니다.</li>
</ul>
</li>
<li><b>주요 메서드:</b><ul>
<li><span class="tt">periodicCheck()</span>: 주기적 메모리 상태 확인</li>
<li><span class="tt">getRuntimeAnalysis()</span>: 런타임 메모리 분석 수행</li>
<li><span class="tt">getStructureAnalysis()</span>: 메모리 구조 분석</li>
<li><span class="tt">getFreeMemory()</span>: 현재 가용 메모리 조회</li>
<li><span class="tt">toggleMonitoring()</span>: 모니터링 토글</li>
<li><span class="tt">toggleTracking()</span>: 메모리 추적 토글</li>
<li><span class="tt">getMemoryReport()</span>: 메모리 추적 리포트 생성</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md44"></a>
IMemoryTracker 인터페이스 정의 ✅ 완료</h3>
<ul>
<li><b>설계 의도:</b><ul>
<li>메모리 사용량 변화 이력을 체계적으로 추적하고 분석하는 기능을 제공합니다.</li>
<li>메모리 스냅샷 저장, 트렌드 분석, 리포트 생성 등의 고급 기능을 지원합니다.</li>
</ul>
</li>
<li><b>핵심 구조체:</b> <div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="struct_memory_snapshot.html">MemorySnapshot</a> {</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> timestamp;    <span class="comment">// 측정 시간</span></div>
<div class="line">    <span class="keywordtype">int</span> freeBytes;             <span class="comment">// 자유 메모리 바이트</span></div>
<div class="line">    <span class="keywordtype">int</span> usedBytes;             <span class="comment">// 사용된 메모리 바이트</span></div>
<div class="line">    std::string eventType;     <span class="comment">// 이벤트 타입</span></div>
<div class="line">    std::string description;   <span class="comment">// 추가 설명</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="struct_memory_report.html">MemoryReport</a> {</div>
<div class="line">    <span class="keywordtype">int</span> totalSnapshots;        <span class="comment">// 총 스냅샷 수</span></div>
<div class="line">    <span class="keywordtype">int</span> minFreeBytes;          <span class="comment">// 최소 자유 메모리</span></div>
<div class="line">    <span class="keywordtype">int</span> maxFreeBytes;          <span class="comment">// 최대 자유 메모리</span></div>
<div class="line">    <span class="keywordtype">int</span> avgFreeBytes;          <span class="comment">// 평균 자유 메모리</span></div>
<div class="line">    <span class="keywordtype">int</span> memoryTrend;           <span class="comment">// 메모리 트렌드</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> duration;    <span class="comment">// 추적 기간</span></div>
<div class="line">    std::string summary;       <span class="comment">// 요약 텍스트</span></div>
<div class="line">};</div>
<div class="ttc" id="astruct_memory_report_html"><div class="ttname"><a href="struct_memory_report.html">MemoryReport</a></div><div class="ttdoc">메모리 변화 분석 리포트 구조체</div><div class="ttdef"><b>Definition</b> IMemoryTracker.h:28</div></div>
<div class="ttc" id="astruct_memory_snapshot_html"><div class="ttname"><a href="struct_memory_snapshot.html">MemorySnapshot</a></div><div class="ttdoc">특정 시점의 메모리 상태를 담는 구조체</div><div class="ttdef"><b>Definition</b> IMemoryTracker.h:12</div></div>
</div><!-- fragment --></li>
<li><b>주요 메서드:</b><ul>
<li><span class="tt">recordSnapshot()</span>: 메모리 스냅샷 저장</li>
<li><span class="tt">recordCurrentMemory()</span>: 현재 메모리 자동 측정 및 저장</li>
<li><span class="tt">generateReport()</span>: 분석 리포트 생성</li>
<li><span class="tt">exportToCsv()</span>: CSV 형식 내보내기</li>
<li><span class="tt">exportReportToMarkdown()</span>: Markdown 리포트 생성</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md45"></a>
MemoryMonitorService 클래스 구현 ✅ 완료</h3>
<ul>
<li><b>설계 의도:</b><ul>
<li><a class="el" href="class_i_memory_analyzer.html" title="메모리 분석 시스템의 동작을 정의하는 인터페이스 (Application Layer)">IMemoryAnalyzer</a> 인터페이스를 구현하여 실제 메모리 모니터링 및 분석 기능을 제공합니다.</li>
<li>HAL 추상화를 통해 하드웨어 독립적 구현을 달성합니다.</li>
<li>메모리 추적 기능을 통합하여 포괄적인 메모리 관리 솔루션을 제공합니다.</li>
</ul>
</li>
<li><b>핵심 기능:</b><ul>
<li>주기적 메모리 모니터링 (기본 10초 간격)</li>
<li>런타임 메모리 스트레스 테스트</li>
<li>메모리 구조 분석</li>
<li>CSV/Markdown 형식 로그 출력</li>
<li>메모리 변화 추적 및 리포트 생성</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md46"></a>
MemoryTrackerService 클래스 구현 ✅ 완료</h3>
<ul>
<li><b>설계 의도:</b><ul>
<li><a class="el" href="class_i_memory_tracker.html" title="메모리 사용량 변화 추적 및 리포트 생성 인터페이스">IMemoryTracker</a> 인터페이스의 완전한 구현체로서 메모리 이력 관리의 모든 기능을 제공합니다.</li>
<li>원형 버퍼 구조를 사용하여 메모리 효율적인 히스토리 관리를 구현합니다.</li>
<li>실시간 메모리 측정 및 트렌드 분석 기능을 포함합니다.</li>
</ul>
</li>
<li><b>핵심 기능:</b><ul>
<li>메모리 스냅샷 자동 수집 및 저장</li>
<li>메모리 사용량 트렌드 분석 (-1: 감소, 0: 안정, 1: 증가)</li>
<li>통계 분석 (최소/최대/평균 메모리 사용량)</li>
<li>CSV/Markdown 형식 데이터 내보내기</li>
<li>히스토리 크기 제한 및 관리</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md47"></a>
통합 메모리 시스템 아키텍처 ✅ 완료</h3>
<ul>
<li><b>의존성 주입 구조:</b> <div class="fragment"><div class="line">MemoryMonitorService</div>
<div class="line">├── IHal (하드웨어 추상화)</div>
<div class="line">└── IMemoryTracker (메모리 추적)</div>
<div class="line">    └── MemoryTrackerService</div>
<div class="line">        └── IHal (하드웨어 추상화)</div>
</div><!-- fragment --></li>
<li><b>시리얼 명령어 통합:</b><ul>
<li><span class="tt">memtrack</span>: 메모리 추적 기능 토글</li>
<li><span class="tt">memreport</span>: 메모리 추적 리포트 생성</li>
<li>기존 명령어와의 완전한 호환성 유지</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md48"></a>
로그 시스템 구조화 ✅ 완료</h3>
<ul>
<li><b>디렉토리 구조:</b><ul>
<li><span class="tt">logs/memory/</span>: 메모리 관련 로그 파일</li>
<li><span class="tt">logs/comfile/</span>: 컴파일 결과 로그 파일</li>
<li><span class="tt">test/logs/</span>: 테스트 결과 로그 파일</li>
</ul>
</li>
<li><b>로그 저장 명령어:</b><ul>
<li>컴파일: <span class="tt">pio run -e uno_r4_wifi -v 2&gt;&amp;1 | tee logs/comfile/compile_results.txt</span></li>
<li>테스트: <span class="tt">pio test -e native -v 2&gt;&amp;1 | tee test/logs/test_results_clean.txt</span></li>
</ul>
</li>
</ul>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md50"></a>
3. 통신 및 명령어 처리 (Infrastructure Layer)</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md51"></a>
ICommandProcessor 인터페이스 정의 ✅ 완료</h3>
<ul>
<li><b>설계 의도:</b><ul>
<li>명령어 처리 시스템의 핵심 인터페이스로서 확장 가능한 명령어 처리 구조를 제공합니다.</li>
<li>시리얼 통신뿐만 아니라 다양한 통신 방식에 대한 추상화를 지원합니다.</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md52"></a>
SerialCommandHandler 클래스 구현 ✅ 완료</h3>
<ul>
<li><b>설계 의도:</b><ul>
<li><a class="el" href="class_i_command_processor.html" title="통신 명령어 처리용 추상 인터페이스 (Infrastructure Layer)">ICommandProcessor</a> 인터페이스를 구현하여 시리얼 통신을 통한 명령어 처리를 담당합니다.</li>
<li>메모리 분석 시스템과의 완전한 통합을 제공하며, RTTI 없는 환경에서도 안전하게 동작합니다.</li>
</ul>
</li>
<li><b>지원 명령어:</b><ul>
<li><span class="tt">memtest</span>: 런타임 메모리 분석 수행</li>
<li><span class="tt">memstress</span>: 메모리 스트레스 테스트 (memtest와 동일)</li>
<li><span class="tt">memstruct</span>: 메모리 구조 분석</li>
<li><span class="tt">memfree</span>: 현재 가용 메모리 조회</li>
<li><span class="tt">memtoggle</span>: 주기적 메모리 모니터링 토글</li>
<li><span class="tt">memtrack</span>: 메모리 변화 추적 토글 (신규)</li>
<li><span class="tt">memreport</span>: 메모리 추적 리포트 생성 (신규)</li>
<li><span class="tt">help</span>/<span class="tt">menu</span>: 사용 가능한 명령어 목록 표시</li>
</ul>
</li>
<li><b>RTTI 대응 설계:</b><ul>
<li>Arduino 환경의 <span class="tt">-fno-rtti</span> 플래그로 인한 <span class="tt">dynamic_pointer_cast</span> 사용 불가 문제 해결</li>
<li><a class="el" href="class_i_memory_analyzer.html" title="메모리 분석 시스템의 동작을 정의하는 인터페이스 (Application Layer)">IMemoryAnalyzer</a> 인터페이스에 <span class="tt">toggleTracking()</span>, <span class="tt">getMemoryReport()</span> 메서드 추가</li>
<li>타입 캐스팅 없이 인터페이스를 통한 안전한 메서드 호출 구현</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md53"></a>
명령어 파싱 및 응답 처리 ✅ 완료</h3>
<ul>
<li><b>명령어 처리 흐름:</b><ol type="1">
<li>시리얼 입력 수신 및 파싱</li>
<li>명령어별 적절한 메서드 호출</li>
<li>결과를 CSV/Markdown 형식으로 포맷팅</li>
<li>시리얼 출력으로 응답 전송</li>
</ol>
</li>
<li><b>에러 처리:</b><ul>
<li>알 수 없는 명령어에 대한 적절한 에러 메시지 반환</li>
<li>메모리 분석 실패 시 안전한 에러 응답 제공</li>
</ul>
</li>
</ul>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md55"></a>
4. 의존성 주입 및 통합 (Main Layer)</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md56"></a>
HAL(Hardware Abstraction Layer) 구현 ✅ 완료</h3>
<ul>
<li><b>설계 의도:</b><ul>
<li>하드웨어 의존성을 완전히 분리하여 테스트 가능한 아키텍처를 구현합니다.</li>
<li>Arduino 하드웨어와 Mock 테스트 환경 모두를 지원하는 추상화 계층을 제공합니다.</li>
</ul>
</li>
<li><b><a class="el" href="class_i_hal.html" title="Hardware Abstraction Layer (HAL) 인터페이스.">IHal</a> 인터페이스:</b> <div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_class" href="class_i_hal.html">IHal</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code hl_function" href="class_i_hal.html#a522492b130b1f00f4ffd8e590095cd7b">millis</a>() = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code hl_function" href="class_i_hal.html#a7a244e7bdb9cce349cead0f61fb6e996">getFreeMemoryBytes</a>() = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::string <a class="code hl_function" href="class_i_hal.html#aabad28bc0352cd84736c10696bcdc7ee">getMemoryStructureInfo</a>() = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code hl_function" href="class_i_hal.html#ae77fcd5a02a24a2ac08209adaa67ac74">print</a>(<span class="keyword">const</span> std::string&amp; message) = 0;</div>
<div class="line">};</div>
<div class="ttc" id="aclass_i_hal_html"><div class="ttname"><a href="class_i_hal.html">IHal</a></div><div class="ttdoc">Hardware Abstraction Layer (HAL) 인터페이스.</div><div class="ttdef"><b>Definition</b> IHal.h:14</div></div>
<div class="ttc" id="aclass_i_hal_html_a522492b130b1f00f4ffd8e590095cd7b"><div class="ttname"><a href="class_i_hal.html#a522492b130b1f00f4ffd8e590095cd7b">IHal::millis</a></div><div class="ttdeci">virtual unsigned long millis() const =0</div><div class="ttdoc">시스템 시작 후 경과된 시간을 밀리초 단위로 반환합니다. (millis()의 추상화)</div></div>
<div class="ttc" id="aclass_i_hal_html_a7a244e7bdb9cce349cead0f61fb6e996"><div class="ttname"><a href="class_i_hal.html#a7a244e7bdb9cce349cead0f61fb6e996">IHal::getFreeMemoryBytes</a></div><div class="ttdeci">virtual int getFreeMemoryBytes() const =0</div><div class="ttdoc">현재 가용 메모리(free memory)의 바이트 수를 반환합니다.</div></div>
<div class="ttc" id="aclass_i_hal_html_aabad28bc0352cd84736c10696bcdc7ee"><div class="ttname"><a href="class_i_hal.html#aabad28bc0352cd84736c10696bcdc7ee">IHal::getMemoryStructureInfo</a></div><div class="ttdeci">virtual std::string getMemoryStructureInfo() const =0</div><div class="ttdoc">메모리 구조 정보를 담은 문자열을 반환합니다.</div></div>
<div class="ttc" id="aclass_i_hal_html_ae77fcd5a02a24a2ac08209adaa67ac74"><div class="ttname"><a href="class_i_hal.html#ae77fcd5a02a24a2ac08209adaa67ac74">IHal::print</a></div><div class="ttdeci">virtual void print(const std::string &amp;message)=0</div><div class="ttdoc">주어진 문자열을 출력합니다. (Serial.println()의 추상화)</div></div>
</div><!-- fragment --></li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md57"></a>
통합 의존성 주입 구조 ✅ 완료</h3>
<ul>
<li><b>의존성 주입 아키텍처:</b> <div class="fragment"><div class="line">main.cpp</div>
<div class="line">├── ArduinoHal (실제 하드웨어)</div>
<div class="line">├── MemoryTrackerService(hal)</div>
<div class="line">├── MemoryMonitorService(hal, tracker)</div>
<div class="line">└── SerialCommandHandler(memoryAnalyzer)</div>
</div><!-- fragment --></li>
<li><b>시스템 초기화 순서:</b><ol type="1">
<li>HAL 객체 생성 (<a class="el" href="class_arduino_hal.html" title="Arduino 프레임워크를 위한 IHal 인터페이스의 실제 구현체.">ArduinoHal</a>)</li>
<li><a class="el" href="class_memory_tracker_service.html" title="IMemoryTracker 인터페이스의 구현체">MemoryTrackerService</a> 생성 및 HAL 주입</li>
<li><a class="el" href="class_memory_monitor_service.html" title="IMemoryAnalyzer 인터페이스의 구현체 (Application Layer)">MemoryMonitorService</a> 생성 및 HAL, Tracker 주입</li>
<li><a class="el" href="class_serial_command_handler.html" title="시리얼 명령어 처리 구현체 (Infrastructure Layer)">SerialCommandHandler</a> 생성 및 MemoryAnalyzer 주입</li>
<li>시스템 동작 시작</li>
</ol>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md58"></a>
컴파일 및 테스트 검증 ✅ 완료</h3>
<ul>
<li><b>Arduino UNO R4 WiFi 컴파일 성공:</b><ul>
<li>RAM 사용량: 22.6% (7,420 bytes / 32,768 bytes)</li>
<li>Flash 사용량: 70.1% (183,848 bytes / 262,144 bytes)</li>
<li>모든 의존성 주입이 정상적으로 동작함</li>
</ul>
</li>
<li><b>Header-Only Mock 테스트:</b><ul>
<li>16개 테스트 케이스 모두 통과</li>
<li>MockMemoryTracker, MockMemoryMonitorService 완전 구현</li>
<li>실제 구현과 Mock 간 100% 호환성 달성</li>
</ul>
</li>
</ul>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md60"></a>
5. 설계 의사결정/이슈/토의</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md61"></a>
메모리 추적 시스템 설계 결정 사항</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md62"></a>
1. RTTI 없는 환경에서의 타입 캐스팅 문제 해결</h4>
<ul>
<li><b>문제:</b> Arduino 환경에서 <span class="tt">-fno-rtti</span> 플래그로 인해 <span class="tt">dynamic_pointer_cast</span> 사용 불가</li>
<li><b>해결책:</b> <a class="el" href="class_i_memory_analyzer.html" title="메모리 분석 시스템의 동작을 정의하는 인터페이스 (Application Layer)">IMemoryAnalyzer</a> 인터페이스에 메모리 추적 관련 메서드 직접 추가</li>
<li><b>장점:</b> 타입 캐스팅 없이 안전한 메서드 호출, 인터페이스 일관성 유지</li>
<li><b>결과:</b> SerialCommandHandler에서 안전하게 메모리 추적 기능 사용 가능</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md63"></a>
2. Header-Only Mock 패턴 확장</h4>
<ul>
<li><b>설계 의도:</b> MockMemoryTracker를 Header-Only 방식으로 구현</li>
<li><b>장점:</b><ul>
<li>컴파일 시간 단축</li>
<li>src 폴더 의존성 완전 분리</li>
<li>테스트 환경의 독립성 보장</li>
</ul>
</li>
<li><b>구현:</b> <a class="el" href="class_i_memory_tracker.html" title="메모리 사용량 변화 추적 및 리포트 생성 인터페이스">IMemoryTracker</a> 인터페이스의 모든 메서드를 Mock으로 완전 구현</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md64"></a>
3. 메모리 추적 데이터 구조 설계</h4>
<ul>
<li><b><a class="el" href="struct_memory_snapshot.html" title="특정 시점의 메모리 상태를 담는 구조체">MemorySnapshot</a> vs <a class="el" href="struct_memory_report.html" title="메모리 변화 분석 리포트 구조체">MemoryReport</a> 분리:</b><ul>
<li><a class="el" href="struct_memory_snapshot.html" title="특정 시점의 메모리 상태를 담는 구조체">MemorySnapshot</a>: 개별 시점의 메모리 상태 저장</li>
<li><a class="el" href="struct_memory_report.html" title="메모리 변화 분석 리포트 구조체">MemoryReport</a>: 전체 추적 기간의 분석 결과 제공</li>
</ul>
</li>
<li><b>장점:</b> 데이터와 분석 결과의 명확한 분리, 확장성 향상</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md65"></a>
4. 원형 버퍼를 활용한 메모리 효율성</h4>
<ul>
<li><b>설계:</b> std::deque를 사용한 히스토리 크기 제한</li>
<li><b>장점:</b> 메모리 사용량 예측 가능, 장기간 동작 시 메모리 오버플로우 방지</li>
<li><b>설정:</b> 기본 100개 스냅샷 제한, 사용자 설정 가능</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md66"></a>
5. 로그 시스템 구조화</h4>
<ul>
<li><b>디렉토리 분리:</b><ul>
<li><span class="tt">logs/memory/</span>: 메모리 관련 로그</li>
<li><span class="tt">logs/comfile/</span>: 컴파일 로그</li>
<li><span class="tt">test/logs/</span>: 테스트 로그</li>
</ul>
</li>
<li><b>장점:</b> 로그 유형별 체계적 관리, 분석 도구 연동 용이</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md67"></a>
향후 확장 고려사항</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md68"></a>
1. 실시간 메모리 시각화</h4>
<ul>
<li>웹 기반 대시보드를 통한 실시간 메모리 상태 모니터링</li>
<li>JSON 형식 데이터 내보내기 기능 추가 예정</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md69"></a>
2. 메모리 누수 탐지</h4>
<ul>
<li>메모리 사용량 트렌드 분석을 통한 누수 패턴 자동 탐지</li>
<li>임계값 기반 알림 시스템 구현 예정</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md70"></a>
3. 다중 센서 연동</h4>
<ul>
<li>DS18B20 센서 데이터와 메모리 사용량 상관관계 분석</li>
<li>센서 개수 증가에 따른 메모리 사용량 패턴 추적</li>
</ul>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md72"></a>
4. 코드 품질 메트릭 모니터링 시스템 ✅ 완료</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md73"></a>
설계 목표 및 구현 상태</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md74"></a>
자동화된 품질 분석 시스템 구축</h4>
<ul>
<li><b>목표</b>: 지속적인 코드 품질 모니터링 및 개선 가이드 제공</li>
<li><b>구현 상태</b>: ✅ 완료 (품질 점수 90.9/100 달성)</li>
<li><b>핵심 기능</b>: 포괄적 메트릭 수집, 트렌드 분석, 자동화 도구</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md75"></a>
주요 구현 컴포넌트</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md76"></a>
1. 코드 품질 메트릭 수집기 (<span class="tt">code_metrics.py</span>)</h4>
<p><b>기능 개요:</b></p><ul>
<li>코드 메트릭: 라인 수, 함수/클래스 개수, 복잡도 분석</li>
<li>아키텍처 메트릭: Clean Architecture 준수도, 의존성 역전 원칙</li>
<li>테스트 메트릭: 커버리지, 성공률, 실행 시간</li>
<li>빌드 메트릭: 컴파일 상태, 메모리 사용률, 경고/오류</li>
</ul>
<p><b>핵심 클래스 구조:</b> </p><div class="fragment"><div class="line"><span class="keyword">class </span>CodeMetricsCollector:</div>
<div class="line">    <span class="keyword">def </span>collect_code_metrics() -&gt; Dict[str, Any]     <span class="comment"># 코드 복잡도 분석</span></div>
<div class="line">    def collect_architecture_metrics() -&gt; Dict[str, Any]  <span class="comment"># 아키텍처 준수도</span></div>
<div class="line">    <span class="keyword">def </span>collect_test_metrics() -&gt; Dict[str, Any]     <span class="comment"># 테스트 품질</span></div>
<div class="line">    def collect_build_metrics() -&gt; Dict[str, Any]    <span class="comment"># 빌드 상태</span></div>
<div class="line">    <span class="keyword">def </span>calculate_quality_score() -&gt; float          <span class="comment"># 종합 품질 점수</span></div>
</div><!-- fragment --><p><b>메트릭 가중치 시스템:</b></p><ul>
<li>아키텍처 메트릭: 30% (계층 분리, 의존성 역전, 인터페이스 사용)</li>
<li>테스트 메트릭: 25% (성공률, 커버리지)</li>
<li>빌드 메트릭: 20% (컴파일 성공, 메모리 효율성)</li>
<li>코드 메트릭: 15% (복잡도, 파일 크기)</li>
<li>문서화: 10% (문서 파일 수)</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md77"></a>
2. 트렌드 분석 시스템 (<span class="tt">trend_analyzer.py</span>)</h4>
<p><b>기능 개요:</b></p><ul>
<li>과거 메트릭 데이터 로드 및 비교 분석</li>
<li>품질 점수 변화 추적 (+30.4점 향상 달성)</li>
<li>자동 권장사항 생성</li>
</ul>
<p><b>주요 분석 항목:</b> </p><div class="fragment"><div class="line">class QualityTrendAnalyzer:</div>
<div class="line">    <span class="keyword">def </span>load_historical_metrics() -&gt; List[Dict]     <span class="comment"># 과거 데이터 로드</span></div>
<div class="line">    def analyze_trends() -&gt; Dict[str, Any]          <span class="comment"># 트렌드 분석</span></div>
<div class="line">    <span class="keyword">def </span>generate_trend_report() -&gt; str              <span class="comment"># 리포트 생성</span></div>
</div><!-- fragment --><h4 class="doxsection"><a class="anchor" id="autotoc_md78"></a>
3. 자동화 스크립트</h4>
<p><b>Windows PowerShell (<span class="tt">monitor_quality.ps1</span>):</b> </p><div class="fragment"><div class="line"># 전체 품질 모니터링 파이프라인</div>
<div class="line">param([switch]$SkipBuild, [switch]$SkipTest, [switch]$Verbose)</div>
<div class="line"> </div>
<div class="line"># 1. 빌드 및 테스트 실행</div>
<div class="line"># 2. 품질 메트릭 수집</div>
<div class="line"># 3. 트렌드 분석</div>
<div class="line"># 4. 결과 요약 출력</div>
</div><!-- fragment --><p><b>Linux/macOS Bash (<span class="tt">monitor_quality.sh</span>):</b></p><ul>
<li>동일한 기능의 Bash 스크립트 버전</li>
<li>Cross-platform 지원</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md79"></a>
현재 품질 점수 상세 분석</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md80"></a>
📊 전체 품질 점수: 90.9/100 (탁월한 품질)</h4>
<p><b>구성 요소별 점수:</b></p><ol type="1">
<li><b>아키텍처 메트릭</b>: 85.0/100<ul>
<li>계층 분리: 90.0/100 (Domain: 2, Application: 5, Infrastructure: 2)</li>
<li>의존성 역전: 80.0/100 (인터페이스: 5, 구현체: 4)</li>
<li>인터페이스 사용: 90.0/100 (Mock 파일: 6개)</li>
</ul>
</li>
<li><b>테스트 메트릭</b>: 100.0/100<ul>
<li>테스트 성공률: 100% (16/16 통과)</li>
<li>실행 시간: 0.86초</li>
<li>커버리지 추정: 40%</li>
</ul>
</li>
<li><b>빌드 메트릭</b>: 95.0/100<ul>
<li>컴파일: ✅ 성공</li>
<li>RAM 사용률: 22.6% (효율적)</li>
<li>Flash 사용률: 70.1% (적절)</li>
<li>경고/오류: 0개</li>
</ul>
</li>
<li><b>코드 메트릭</b>: 100.0/100<ul>
<li>평균 복잡도: 0.6 (매우 낮음)</li>
<li>총 라인 수: 1,222</li>
<li>함수: 72개, 클래스: 10개</li>
</ul>
</li>
</ol>
<h3 class="doxsection"><a class="anchor" id="autotoc_md81"></a>
CI/CD 통합</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md82"></a>
GitHub Actions 워크플로우 확장</h4>
<div class="fragment"><div class="line">- name: Run code quality metrics analysis</div>
<div class="line">  run: python tools/quality_metrics/code_metrics.py</div>
<div class="line"> </div>
<div class="line">- name: Upload quality metrics</div>
<div class="line">  uses: actions/upload-artifact@v4</div>
<div class="line">  with:</div>
<div class="line">    name: quality-metrics</div>
<div class="line">    path: |</div>
<div class="line">      logs/quality/*.json</div>
<div class="line">      logs/quality/*.md</div>
</div><!-- fragment --><h4 class="doxsection"><a class="anchor" id="autotoc_md83"></a>
자동 품질 게이트</h4>
<ul>
<li>품질 점수 85점 이상 유지 목표</li>
<li>테스트 성공률 95% 이상 필수</li>
<li>메모리 사용률 모니터링 (RAM &lt; 80%, Flash &lt; 85%)</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md84"></a>
생성되는 보고서</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md85"></a>
1. 품질 메트릭 리포트 (<span class="tt">quality_report_*.md</span>)</h4>
<ul>
<li>전체 품질 점수 및 구성 요소별 상세 분석</li>
<li>코드 구조 분석 (파일 수, 라인 수, 복잡도)</li>
<li>아키텍처 준수도 평가</li>
<li>테스트 및 빌드 상태 요약</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md86"></a>
2. 트렌드 분석 리포트 (<span class="tt">trend_report_*.md</span>)</h4>
<ul>
<li>품질 점수 변화 추적</li>
<li>메트릭별 상세 변화 분석</li>
<li>자동 생성 권장사항</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md87"></a>
3. JSON 데이터 (<span class="tt">metrics_*.json</span>, <span class="tt">trend_analysis_*.json</span>)</h4>
<ul>
<li>머신리더블 형태의 상세 메트릭 데이터</li>
<li>외부 도구 연동 및 추가 분석 지원</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md88"></a>
품질 개선 가이드라인</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md89"></a>
개발 워크플로우 권장사항</h4>
<ol type="1">
<li><b>코드 변경 후</b>: <span class="tt">python tools/quality_metrics/code_metrics.py</span> 실행</li>
<li><b>일일 체크</b>: PowerShell 자동화 스크립트 활용</li>
<li><b>주간 리뷰</b>: 트렌드 분석 보고서 검토</li>
<li><b>릴리스 전</b>: 전체 품질 점수 85점 이상 확인</li>
</ol>
<h4 class="doxsection"><a class="anchor" id="autotoc_md90"></a>
품질 점수 기준</h4>
<ul>
<li><b>90-100점</b>: 🎉 탁월한 품질 (현재 상태)</li>
<li><b>80-89점</b>: ✅ 좋은 품질</li>
<li><b>70-79점</b>: ⚠️ 수용 가능한 품질</li>
<li><b>0-69점</b>: 🚨 개선 필요</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md91"></a>
향후 확장 계획</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md92"></a>
1. 정적 분석 도구 확장</h4>
<ul>
<li>cppcheck 완전 통합</li>
<li>clang-tidy 추가 규칙 적용</li>
<li>메모리 안전성 분석 강화</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md93"></a>
2. 커버리지 분석 고도화</h4>
<ul>
<li>gcov/lcov 통합</li>
<li>실제 코드 커버리지 측정</li>
<li>브랜치 커버리지 분석</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md94"></a>
3. 성능 메트릭 추가</h4>
<ul>
<li>실행 시간 프로파일링</li>
<li>메모리 할당 패턴 분석</li>
<li>전력 소비 모니터링</li>
</ul>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md96"></a>
주요 성과 요약</h3>
<p>✅ <b>완료된 핵심 기능:</b></p><ul>
<li>메모리 변화 추적 및 이력 관리</li>
<li>실시간 메모리 분석 리포트 생성</li>
<li>CSV/Markdown 형식 데이터 내보내기</li>
<li>Arduino UNO R4 WiFi 환경 컴파일 성공</li>
<li>16개 테스트 케이스 100% 통과</li>
<li><b>코드 품질 메트릭 모니터링 시스템 (90.9/100 점수 달성)</b></li>
</ul>
<p>✅ <b>아키텍처 개선:</b></p><ul>
<li>RTTI 없는 환경에서 안전한 인터페이스 설계</li>
<li>Header-Only Mock 패턴으로 완전한 의존성 분리</li>
<li>HAL 추상화를 통한 하드웨어 독립적 구현</li>
<li><b>Clean Architecture 준수도 85점 달성</b></li>
</ul>
<p>✅ <b>개발 효율성:</b></p><ul>
<li>자동화된 빌드/테스트/로그 시스템</li>
<li>체계적인 문서화 및 버전 관리</li>
<li>CI/CD 파이프라인 통합</li>
<li><b>포괄적 품질 모니터링 및 트렌드 분석 도구</b></li>
</ul>
<p>✅ <b>품질 보증:</b></p><ul>
<li>지속적 품질 모니터링 체계 구축</li>
<li>자동화된 메트릭 수집 및 분석</li>
<li>트렌드 기반 개선 권장사항 생성</li>
<li><b>Cross-platform 자동화 스크립트 지원</b></li>
</ul>
<hr  />
<blockquote class="doxtable">
<p>각 항목별로 설계/구현/예제/이슈/토의 내용을 자유롭게 추가·수정해 주세요. </p>
</blockquote>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">다음에 의해 생성됨 :  <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
